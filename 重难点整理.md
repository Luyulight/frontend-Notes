## 善用MDN Web Docs

## 1.CSS选择器

```css
.class  //包含类
.class1.class2 //单元素同时包含多类
#id     //id选择器
*		//所有元素
element1,element2 //所有element1,2元素
div p	//div下的所有p (包含间接子元素)
div>p	//父元素为div的p
div+p	//紧跟div的首个P()  参考li+li{...}除了第一行li之外所有添加属性
p~ul	//前面有<p>的所有<ul>
a[target=_blank]	//属性选择器
a[title~=flower]  a[title*=flower]  //包含
a[title|=en] a[title^=en]			//以en开头
a[title&=en]						//以en结尾
:active :hover :focus
:link :visited :checked :invalid :optional :target
:first-child :last-child :first-of-type :last-of-type
::after ::before
::selection
伪类很多详见https://www.w3school.com.cn/cssref/css_selectors.asp
```

## 2.CSS display

### Grid布局

[详见指南](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

```CSS
.container {
	display:grid/inline-grid;
    grid-template-colunms: 1fr 1fr/33% 33% 33%/repeat(n,11px)/100 auto 100;
    grid-template-rows: 1fr 1fr/33vh 33vh 33vh/repeat(n,11px);
}
//最新标准，属性前的'grid-'可以略去
//网格线可以命名
grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
grid-template-rows: [r1] 100px [r2] 100px [r3] auto [[fifth-line row-5]];
//未声明指定宽高
grid-auto-colunms: 50px;
grid-auto-rows: 50px;

//行间距和列间距
grid-gap: 20px 20px
grid-row-gap: 20px;
grid-column-gap: 20px;
grid-template-areas: 'a b c'
                   	 'd e f'
                     'g h i';
grid-template-areas: "header header header"
                     "main main sidebar"
                     "footer footer footer";//不需要使用的网格区域可以用(.)表示
[header-start] [header-end]
grid-auto-flow: row/colunm; 默认横纵排序 row dense/colunm dense 紧密填满
//单元格的 内容 对齐
justify-items: start | end | center |stretch
align-items: start | end | center | stretch
place-items:<align-items> <justify-items>
//内容区域对齐 整个container相对于父元素的对齐
//space-between:项目项目间隔相等，项目和容器边框之间无间隔（项目指一列单元格或者一行单元格）
//space-around:项目两侧间隔相等，所以项目之间的间隔是项目和容器边框间隔的2倍
//space-evenly:间隔全相等
justify-content: start | end | center | stretch | space-around | space-between 						| space-evenly;
align-content:   start | end | center | stretch | space-around | space-between 					 	| space-evenly;
place-content:<align-content> <justify-content>
//项目定位：占哪些单元格
.item1 {
    grid-colunm-start:header-start  |  1;
    grid-colunm-end:header-end  |  3;
    <=> grid-colunm: <start-line>/<end-line>
    grid-row-start:2;
    grid-row-end:4;
    <=>grid-row: <start-line>/<end-line>
    grid-colunm-start: span 2; <=> grid-colunm-end: span 2;
    grid-area: e,f;
或者 grid-area: <row-start> / <column-start> / <row-end> / <column-end>;
}
//项目自身 （单元格内容）的对齐
.item1 {
    justify-self: start | end |center | stretch;
    align-self: start | end | center | stretch;
    place-self: <align-self><justify-self>;
}
```

### Flex布局

[详见指南](https://zhuanlan.zhihu.com/p/25984121)

```css
flex-container: main axis, cross axis, main/cross方向可指定
flex items: main size/cross size 根据指定的main轴的方向来区别宽高
!!!!!!容器设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。
.container {
	display: flex | inline-flex;
	flex-direction:row | row-reverse | colunm | colunm-reverse;//主轴方向
	flex-wrap: nowrap | wrap | wrap-reverse; //容器内是否可换行
	//no-wrap不换行，如果主轴尺寸固定 溢出时 项目尺寸会被挤压
	flex-flow: <flex-direction> || <flex-wrap>;
}
//主轴方向对齐
.container {
	justify-content: flex-start | flex-end | center | space-betweem          |                      space-around;
	//flex-start/end 左右对齐(呸，起点终点对齐)
	//center居中
	//space-between两端对齐，中间间隔相等
	//space-around 每个项目两侧间隔相等，即距两边一个单位，项目项目之间两个单位
}
//交叉轴方向对齐
.container {
	align-items: flex-start | flex-end | center | baseline | stretch;
	//项目未设置height或者height:auto，默认为stretch即撑满整个容器高度
	//flex-start/end 交叉轴起终点对齐
	//center 居中
	//baseline 项目第一行文字基线对齐
}
//align-content: 定义了多根轴线的对齐方式(nowarp情况)，如果只有一根轴线，那么该属性将不起作用
.container {
    align-content: flex-start | flex-end | center | space-between | 
        			space-around | stretch;
    //多个轴线stretch会平分垂直空间
    //其他的类似于justify-content的规则
}
//元素属性
.item {
    order:<integer>;//排序的顺序
}
.item {
    flex-basis: <length> | auto; //默认占据的主轴空间，auto则是原有的width或者height
    (主要用于计算主轴剩余空间以对对齐属性分配)
    flex-grow:<number> //在存在剩余空间的情况下项目放大比例 默认值0 存在剩余空间也不放大
    flex-shrink:<number> //空间不足的情况下缩小比例 默认值1  设为0时不缩小
}
.item {
    flex: none | [<'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ];
    //flex-basis,flex-grow,flex-shrink的组合
    //默认值 0 1 auto
    //快捷值 auto(1 1 auto) none(0 0 auto)
    //当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 
    //当 flex 取值为 0 时，对应的三个值分别为 0 1 0%
	//当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 	  取 1
    //当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 		 取 0%
    //当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的		值，flex-shrink 取 1
}
总结：！！！！！ 简写形式 flex-grow 和 flex-shrink默认都是1， flex-basis为0%
    根据输入的数字或者长度 以及输入的个数来进行部分填充修改
补充： flex-wrap设置为wrap|wrap-reserve时, flex grow起作用，flex-shrink不起作用(空间足够)
	  flex-wrap为nowrap时，都起作用
.item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
    //规则类似container的align-items，但是仅对单元素生效
}
```

**flex布局需要一些浏览器前缀以实现对大多数浏览器的兼容。**

**并且flex布局的标准一直在变。下面是一个Sass处理的一个示例：**

```scss
@mixin flexbox() {
  display: -webkit-box;
  display: -moz-box;
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

@mixin flex($values) {
  -webkit-box-flex: $values;
  -moz-box-flex:  $values;
  -webkit-flex:  $values;
  -ms-flex:  $values;
  flex:  $values;
}

@mixin order($val) {
  -webkit-box-ordinal-group: $val;  
  -moz-box-ordinal-group: $val;     
  -ms-flex-order: $val;     
  -webkit-order: $val;  
  order: $val;
}

.wrapper {
  @include flexbox();
}

.item {
  @include flex(1 200px);
  @include order(2);
}
```

### Table布局

```css
简单来说就是:
table    { display: table }
tr       { display: table-row }
thead    { display: table-header-group }
tbody    { display: table-row-group }
tfoot    { display: table-footer-group }
col      { display: table-column }
colgroup { display: table-column-group }
td, th   { display: table-cell }
caption  { display: table-caption }
```

## 3.CSS position

[详见指南](http://www.ruanyifeng.com/blog/2019/11/css-position.html)

### position:static

```css
// static是position属性的默认值
//浏览器按照源码顺序决定每个元素的位置(正常的页面流 normal flow)
//每个块级元素占据自己的区块(block)，元素元素之间不重叠
!!!static定位时，元素的top,bottom,left,right属性无效
```

### position:relative

```css
//relative表示，相对(static定位)的默认位置进行偏移
//需要搭配top,bottom,left,right使用
不脱离文档流
```

### position:absolute

```css
//absolute表示,相对于上级元素(一般是父元素)进行偏移，定位基点是父元素。
//父元素不能是static定位，否则定位基点将变成整个网页的根元素。
//需要搭配top,bottom,left,right使用
脱离文档流
```

### position:fixed

```css
//fixed表示相对于 视窗 进行偏移 定位基点是浏览器窗口
//如果搭配top,bottom,left,right则计算初始位置
//否则初始位置是元素的默认位置
脱离文档流
```

### position:sticky（2017年以后）

```css
//sticky表示基于用户的滚动位置来定位。
//粘性定位的元素是依赖于用户的滚动，在relative 与 fixed 定位之间切换。
//跨越特定阈值前为相对定位，之后为固定定位。
//这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。
不脱离文档流
```

### position:sticky的一些特殊应用

```css
1.元素滚动堆叠
2.简单表格的表头固定
！！！！sticky必须设在<th>元素上面，不能设在<thead>和<tr>元素，因为这两个元素没有relative定位，也就无法产生sticky效果。
```

脱离文档流会造成父元素高度坍塌

**脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute  positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。**

**文档流** 实际上是一种民间说法，官方说法是 **常规流**（normal flow）

**文档流** 的官方概念：**元素按照其在HTML文件中的位置顺序，决定它在显示器上如何排布的过程。主要的形式是自上而下，一行接一行，每一行从左至右。**

## 4.行内元素与块级元素

**行内元素：**与其他元素在一行   宽高不可设   水平方向margin,padding有效，竖直方向的没用

**块级元素：**独占一行   可设宽高，默认100%    margin，padding均有效

```html
常见行内元素：
<a>,<b>,<em>强调,<strong>粗体强调,<strike>中划线,<i>,<input>,<label>,<span>,<select>,<textarea>
!!<br>!!,<img>,
<u>下划线,<sub>下标,<sup>上标,
```

```html
常见块级(内联)元素：
<div>,<dir>,<p>,<h1>....标题,<form>,<ul>,<ol>,<dl>,<hr>水平分割线,
<menu>,<fieldset>form控制组,<pre>格式化文本,<table>
```

```css
行内元素和块级元素转换:
display:
    display:block;
    display:inline;
float:
	设置float以后，该行内元素的display会被赋予block属性
position:
	position:absolute和position:fixed会将原先的行内元素变为块级元素
```

```
inline-block的特殊性:
可以让元素既能设置宽高，又能以inline的方式默认显示。
只有inline-block的元素可以设置vertical-align属性。
但是inline-block有一个隐藏问题，其实不算问题：
设置liline-block的元素间会有间隙，
这个空隙是因为块级元素会换行，就有换行，HTML 中的换行符、空格符、制表符等合并为空白符.所以换行符会占据宽度,产生间隙 
处理的方式也有挺多，举例：
标签换行写法改为标签内回车，设置margin等等
！！特殊的：如果是底部出现间隙，设置vertical-align是top/bottom/middle都可以解决此问题。
```

参考张鑫旭的博客[去除inline-block元素间间距的N种方法](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%e5%8e%bb%e9%99%a4%e9%97%b4%e8%b7%9d/)

```html
可变元素：根据上下文语境决定该元素为块元素或者块级（内联）元素
<button> <del> <iframe> <object> <map> <script>
```

## 5.盒子模型

![img](https://upload-images.jianshu.io/upload_images/4160415-f06e2ce3b5971909.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### content-box和border-box

width和height的区别，borderbox的宽高 = content的宽高+（内边距+边框宽度）*2

​										contentbox的宽高 = content的宽高

chrome默认是content-box，IE默认是border-box

如果不设置背景属性，背景默认会覆盖到border

```css
background-clip:border-box | content-box;
```

### 盒子水平居中

可以让一个盒子实现水平居中，需要满足一下两个条件：

​           块级元素和盒子必须指定宽度（width）

　　   左右的外边距都设置为auto，就可使块级元素水平居中。

### 外边距合并

margin属性有一个特别的行为，就是外边距合并，这个行为只对普通文档流中的块级元素的**垂直外边距有效；**行内框（inline-block）、浮动元素(float)和绝对定位(position:absolute)的原素不会发生外边距合并。

外边距合并主要有两种情况：

​		 1、**同一层相邻元素之间**两个或多个垂直毗邻的兄弟元素，上面元素的下边距会与下面元素的上边距发生合并，合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。

​		2、**没有内容将父元素和后代元素分开**父元素和子元素之间，父元素的上外边距和第一个子元素的上外边距、父元素的下外边距和最后一个子元素的下外边距。发生这种情况的前提是父元素和第一个（或最后一个）子元素之间不存在边框和内边距把外边距分隔开，合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。（负数正数则相加）（注意合并后都会以父元素的外边距形式展示）

​		3、**空的块级元素** 元素本身没有高度但是有上下边距，上下边距会合并。

## 6.【实践】水平垂直居中的对齐方式(10种)

### 居中元素定宽高：

#### ①absolute + 负margin 

```css
.box {
    width:200px;
    height:200px;
    padding:10px;
	position:absolute;
	top:50%;
    left:50%;
    //这里根据盒子模型需要判断的位移的距离
    margin-left:-100px | -110px;
    margin-top:-100px | -110px;
    box-sizing: border-box | content-box;
}
```

#### ②absolute + margin auto

```css
.box {
    position: absolute;;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
	width:200px;
    height:200px;
    padding:10px;
}
```

#### ③absolute + calc

```css
.box {
    position: absolute;;
    top: calc(50% - 50px);
    left: calc(50% - 50px);
}
```

### 居中元素不定宽高:

#### ④absolute + transform

```css
.box {
	position: absolute;;
    top:50%;
    left:50%;
    transform: translate(-50%, -50%);
}
```

#### ⑤lineheight

```css
.container {
    width:auto;
    height:400px;
    line-height:400px;//
    text-align:center//
}
.box {
    display: inline-block;//
    vertical-align: middle;//
    line-height: initial;
}
```

vertical-align:middle有时候对单容器元素不起作用，有如下两种解决方法：

1）给container元素设置display:table-cell;和vertical-align:middle;（不推荐）

```css
.container {
    width:auto;
    height:400px;
    line-height:400px;//
    text-align:center//
    display:table-cell;
    vertical-align:middle;
}
.box {
    display: inline-block;//
    line-height: initial;
}
```

2)在box div的前或后添加一个help div,宽度为0，高度100%,设置相同

```css
.container {
    width:auto;
    height:400px;
    line-height:400px;//
    text-align:center//
}
.box {
    display: inline-block;//
    vertical-align: middle;//
    line-height: initial;
}
.help {
    width: 0;
    height: 100%;
    vertical-align: middle;
    display: inline-block;
}
```

#### ⑥writing-mode

writing-mode可以改变文字的显示方式,同时水平方向的对齐也会对应到垂直方向

但是元素不能写到.box里面了，需要再套一个内层的div

```css
 <div class="container">
    <div class="box"><div class="inner">文本文本文本</div></div>
 </div>
.container {
	width:300px;
	height:300px;
	writing-mode:vertical-lr;
	text-align:center;
}
.box {
	writing-mode:horizontal-tb;
    text-align:center;
    display: inline-block;
    width:100%;
}
.inner {
	display:inline-block;
	margin:auto;
	text-align:left;//修正文字对齐
}
```

#### ⑦table(不推荐，代码冗余)

td本身是垂直居中的，text-align:center并且内存display:inline-block即可

#### ⑧CSS-table

```css
.container {
    display:table-cell;
    text-align:center;
    vertical-align:middle;
}
.box {
    display:inline-block;
}
```

#### ⑨flex布局

```css
.container {
    display:flex;
    justify-content:center;
    align-items:center;
}
```

#### ⑩grid布局

```css
.container {
    display:grid;
    justify-content:center;/justify-items:center
    align-items:center;align-content:center
}
```

或者容器不设置，元素设置align-self;justify-self;

## 7.(script)标签的加载流程

有点长，见[<script>标签元素](https://www.jianshu.com/p/028635fc2ab6) 。

## 8.浏览器渲染页面的步骤

#### ①DNS解析

DNS解析是一个递归查询的过程。

本地域名服务器 - 根域名服务器 - com顶级域名服务器

查询到的缓存在本地。

#### ②TCP连接

SSL握手

```markdown
第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。

第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。

第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。

第四步，服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。

第五步，客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。
```

#### ③发送HTTP请求（HTTP->(SSL/TLS)->TCP->IP）(请求行，请求报头，请求正文)

有哪些请求：GET POST HEAD(1.0), PUT PATCH DELETE OPTIONS  TRACE CONNECT(1.1) 

**GET POST的区别？**

语义不同，本质上没有区别。(TCPl链接)

区别在于不同的使用场景的规范，和不同浏览器/服务器/接口的实现方式。

（一般来说GET参数在URL，POST在Request Body中，但是实际上都可以)

浏览器请求的GET/POST 和 接口中的GET/POST。

一般来说，GET产生一个TCP数据包，POST两个。GET header data 一起发送（因为就是URL），服务器200；POST先发header,服务器100 continue，浏览器继续发送data，服务器响应200。

GET如果发送body也可以两步走，先100再200。

(两次包的好处，网络环境差的情况下，两次包方便TCP验证数据完整性)

并不是所有浏览器POST都会发送两次包，比如Firefox就发送一次。

**header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。**

#### ④服务器处理请求并返回HTTP报文（状态码，响应报头，响应报文）

状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- 1xx：指示信息–表示请求已接收，继续处理。

   		100 客户端继续发送请求

  ​		 101 服务器根据客户端请求切换协议，主要用于websocket和http2升级

- 2xx：成功–表示请求已被成功接收、理解、接受。

  ​		 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回

  ​		 201（已创建）：请求成功并且服务器创建了新的资源

  ​		 202（已创建）：服务器已经接收请求，但尚未处理

  ​		 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源

  ​	 	204（无内容）：服务器成功处理请求，但没有返回任何内容

  ​		 205（重置内容）：服务器成功处理请求，但没有返回任何内容

  ​		 206（部分内容）：服务器成功处理了部分请求 （断点续传或者视频文件等大文件加载）

- 3xx：重定向–要完成请求必须进行更进一步的操作。

  ​		 300（多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 (会缓存)

  ​		 301（永久移动）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置（不会缓存）

  ​		 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

  ​		 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码

  ​		 305 （使用代理）：请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理

  ​		 307 （临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

- 4xx：请求有语法错误或请求无法实现。代表了客户端看起来可能发生了错误，妨碍了服务器的处理

  ​		 400（错误请求）：服务器不理解请求的语法

  ​		 401（未授权）：请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。

  ​	 	403（禁止）：服务器拒绝请求

  ​	 	404（未找到）：服务器找不到请求的网页

  ​		 405（方法禁用）：禁用请求中指定的方法

  ​		 406（不接受）：无法使用请求的内容特性响应请求的网页

  ​		 407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理

  ​		 408（请求超时）：服务器等候请求时发生超时

- 5xx：服务器端错误–服务器未能实现合法的请求。表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

    	   500（服务器内部错误）：服务器遇到错误，无法完成请求

  ​		 501（尚未实施）：服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码

  ​		 502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应

  ​		 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）

  ​		 504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求

  ​		 505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本

- 特殊：

  ​		 304： 协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回的页面只有头部信息，没有内容部分

  ​	 

#### ⑤浏览器解析渲染页面

reflow和repain

refiow:DOM节点中的各个元素都是以盒模型的形式存在，浏览器去计算其位置和大小等。

repain:绘制内容。

reflow必然导致repain

浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复前面过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。

#### ⑥连接结束

## 9.URL编码

"只有字母和数字[0-9a-zA-Z]、一些特殊符号"$-_.+!*'(),"[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。"

**网址路径的编码，用的是utf-8编码。**

**查询字符串的编码，用的是操作系统的默认编码。**?mid=13218

**GET和POST方法的编码，用的是网页的编码。**

**在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。**

解决编码混乱的方法：使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。

escape() 老方法

encodeURI() , encodeURIComponent(),decodeURI(),decodeURIComponent();

## 10.重定向

转发和重定向。

字面意义

## 11.跨域

#### **①为什么会出现跨域问题**

出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）

#### **②什么是跨域**

当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域

#### **③非同源限制**

无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB

无法接触非同源网页的 DOM

无法向非同源地址发送 AJAX 请求

#### **④跨域解决方法**

**【1】****设置document.domain解决无法读取非同源网页的 Cookie问题**

因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）www.test.com / blog.test.com

```js
// 两个页面都设置
document.domain = 'test.com';
```

【2】**跨文档通信 API：window.postMessage()**

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递

```js
// 父窗口打开一个子窗口
var openWindow = window.open('http://test2.com', 'title');
// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)
openWindow.postMessage('Nice to meet you!', 'http://test2.com');
//监听message消息
window.addEventListener('message', function (e) {
  console.log(e.source); // e.source 发送消息的窗口
  console.log(e.origin); // e.origin 消息发向的网址
  console.log(e.data);   // e.data   发送的消息
},false);
```

**【3】****JSONP**

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。

核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

```html
<!--原生实现-->
<script src="http://test.com/data?callback=dosomething"></script>
<script type="text/javascript">
	function dosomething(res){
        console.log(res.data);
    }
</script>
```

```js
<!--jQuery ajax-->
$.ajax({
    url:"http://www.test.com:8080/login",
    type:"get",
    dataType:'jsonp',
    jsonCallback:'handleCallback',
    data:{}
})
```

```vue
<!--vue-->
this.$http.jsonp('http://www.test.com:8080/login',{
	params:{},
	jsonp:'handleCallback',
}).then((res)=>{
	console.log(res);
});
```

**【4】****CORS**

CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。

1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin

2、带cookie跨域请求：前后端都需要进行设置

**【前端设置】**根据xhr.withCredentials字段判断是否带有cookie

```js
<!--原生ajax实现-->
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容
 
// 前端设置是否带cookie
xhr.withCredentials = true;
 
xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');
 
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
```

```ajax
<!--jQuery ajax实现-->
$.ajax({
   url: 'http://www.test.com:8080/login',
   type: 'get',
   data: {},
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
});
```

```vue
<!--vue-resource-->
Vue.http.options.credentials = true
```

```js
<!--axios-->
axios.defaults.withCredentials = true
```

**【服务端设置】**服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

```apache
Apache服务器
Header set Access-Control-Allow-Origin *
```

```php
//php后台
<?php 
header("Access-Control-Allow-Origin:*")
```

```javascript
//node.js后台
var http = require('http');
var server = http.createServer();
var qs = require('querystring');
 
server.on('request', function(req, res) {
    var postData = '';
    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });
    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);
        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });
        res.write(JSON.stringify(postData));
        res.end();
    });
});
 
server.listen('8080');
console.log('Server is running at port 8080...');
```

```java
/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */
 
// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 
 
// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
response.setHeader("Access-Control-Allow-Credentials", "true"); 
 
// 提示OPTIONS预检时，后端需要设置的两个常用自定义头
response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");
```

**【5】服务端代理（参考researchApi)**

服务端请求不会跨域

![img](https://user-gold-cdn.xitu.io/2020/4/13/1717441c9f004d9b?imageslim)

![img](https://user-gold-cdn.xitu.io/2020/4/13/1717441cb6c9453f?imageslim)

[10种跨域解决方案](https://juejin.cn/post/6844904126246027278#heading-3)

## 12.Cookie,Session,Local Storage

### 什么是cookie

cookie是保存在客户端的纯文本文件。

cookie的作用就是用来解决   如何记录客户端的用户信息

name?登陆状态？访问记录？

Cookie以name=值 的形式存储

```js
document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/";
```



注意

```
Cookie 可以创建由超文本标记语言 (HTML) 页中的客户端脚本 （例如，通过使用 Microsoft Visual Basic 脚本版或 JScript 编写的脚本），通过使用 Microsoft Win32 互联网功能 （Win32 程序InternetSetCookie 和 InternetGetCookie），或由服务器端脚本 （例如，一个 Active Server Pages [ASP] 页面上，在 Visual Basic 脚本版本中编写的脚本或通用网关接口 [CGI] 脚本）。
```



### **cookie和session**

**cookie和session都是用来跟踪浏览器用户身份的会话方式**

cookie不设置过期事件保存在内存中，随浏览器关闭结束，设置过期事件保存在硬盘中。每次请求会带上cookie。

session保存在服务端，并且sessionid被包含在cookie中。

用户禁用cookie则需要URL重写，将sessionid拼接到地址后。

单个cookie不超过4kb,session大小无限制。

**优缺点：**

cookie大小受限，功能受限(会被禁用)，安全性低，浪费带宽，但可以管理path。

session占内存，多用户在线服务器压力大，依赖cookie，创建随意，不好维护。

#### localStorage和sessionStorage

WebStorage提供了两种API：**localStorage（本地存储）**和**sessionStorage（会话存储）**

**WebStorage两个主要目标：**

```
1.提供一种在cookie之外存储会话数据的路径
2.提供一种存储大量可以跨会话存在的数据的机制
```

localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。

sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。

localStorage和sessionStorage的存储数据大小一般都是：5MB

localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信

localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理

localStorage：**window.localStorage**
sessionStorage：**window.sessionStorage**

#### WebStorage的优点

（1）存储空间更大：cookie为4KB，而WebStorage是5MB

（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务端的交互，节省了网络流量

（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便

（4）快速显示：有的数据存储在WebStorage上再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快

（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说会比较高一些，不会担心截获，但是仍然存在伪造问题

（6）WebStorage提供了一些方法，数据操作比cookie方便

```
setItem(key, value) —— 保存数据，以键值对的方式存储信息
getItem(key) —— 获取数据，将键值传入，即可获取到对应的value值
removeItem(key) —— 删除单个数据，根据键值移除对应的信息
clear() —— 删除所有的数据
key(index) —— 获取某个索引的key
```

## 13.JS事件

**事件冒泡：**<div> -> <body> -> <html> -> <document> -> (window)

有些事件不支持冒泡：

**事件捕获:**   (window) -> <document> -> <html> -> <body> -> <div>

IE9, Firefox,Chrome,Safari的事件终点是window对象。

IE的事件流叫事件冒泡，事件捕获是Netscape Communicator团队提出的另一种事件流。

老版本浏览器不支持，所以事件捕获的使用场景较少。

**DOM2级事件开始标准化DOM事件**

规定，**DOM事件流**包括三阶段:事件捕获阶段，处于目标阶段，事件冒泡阶段。

![image-20210416105526442](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416105526442.png)

在DOM事件流中，实际的目标(div)在捕获阶段不会接收到事件。在捕获阶段，事件从document到<html>再到<body>后就停止了。

然后是“处于目标”阶段,事件在<div>上发生，并在事件处理中被砍成冒泡阶段的一个部分。然后，冒泡阶段发生，事件又传播回文档。

多数实现DOM事件流的浏览器都实现了规范要求的“捕获阶段不涉及事件目标”

**但是在IE9,Safari,Chorme，Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件**

### 事件处理：

#### **①HTML事件处理：**

例如

```html
<input type="button" value='Click Me' onclick="alert('Clicked')" />
<input type="button" value='Click Me' onclick="showMessage(this,event)" />
//这么写会有“时差”问题（触发时showMessage并未解析），所以使用try-catch来捕获异常
<input type="button" value='Click Me' onclick="try{showMessage();}catch(ex){}" />
```

这样写有一个隐藏用法，就是扩展作用域的方式。

```html
<input type="button" value='Click Me' onclick="console.log(event)"/>
//click event
<input type="button" value='Click Me' onclick="console.log(this)"/>
//input本身
<input type="button" value='Click Me' onclick="console.log(value)"/> 
//'Click Me'
```

```html
<input type="button" id='username' value='dasdafdsa'/>
<input type="button" value='Click Me' onclick="console.log(username.value)"/>
//dasdafdsa
```

#### ②DOM0级事件处理程序

以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理.

**0级对每个事件只支持一个事件处理程序**

```js
var btn = document.getElementById("myBtn");
btn.onclick = function() {
	alert(this.id);			//function的作用域在元素中 this是当前元素
}
btn.onclick = null; 		//删除事件处理程序
```

#### ③DOM2级事件处理程序

第三个布尔参数，表示事件在捕获阶段或者冒泡阶段调用处理程序(true捕获，false冒泡)

大多数情况下都是添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器

```js
var btn = document.getElementById("myBtn");
btn.addEventListener('click',function(){
	alert(this.id);
},false)
btn.addEventListener('click',function(){
	alert('hello world');
},false)
//会按照顺序触发，id->hello world
```

通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除

传入的参数相同，所以**！！匿名函数无法被移除(如上代码段中添加的事件)！！**

#### **④IE事件处理程序**

attachEvent和detachEvent

IE8及更早版本只支持冒泡，所以通过如上方式添加的事件处理程序都会被添加到冒泡阶段。

与0级和2级不同，它的**作用域是window**

```js
var btn = document.getElementById("myBtn");
btn.attachEvent('onclick',function(){
	alert('id'); //它的作用域是window
},false)
btn.attachEvent('onclick',function(){
	alert("hello world");
},false)
//与DOM2级相反 ，hello world->id
```

类似的，匿名函数无法被移除

### 兼容跨浏览器的事件处理写法：

```js
//定义
var EventUtil = {
  addHandler: function(element, type, handler){
  	  if(element.addEventListener){
          element.addEventListener(type, handler, false);
      }else if(element.attachEvent){
          element.attachEvent("on"+type, handler);
      }else{
          element["on"+type] = handler;
      }
  },
  removeHandler: function(element, type, handler){
      if(element.removeEventListener){
          element.removeEventListener(type, handler, false);
      }else if(element.detachEvent){
          element.detachEvent("on"+type, handler);
      }else{
          element["on"+type] = null;
      }
  }
};
//调用
var btn = document.getElementById("myBtn");
var handler = function(){
    alert("Clicked");
}
EventUtil.addHandler(btn, "click", handler);
EventUtil.removeHandler(btn, "click", handler);
```

### DOM事件对象：

event这个变量存储了event对象，**不管function参数里带没带event,都可以在事件处理函数中直接写event来获取作用域的event对象。**

在HTML事件处理中，onclick="func1()"是没有默认值的，func1(this)传this,则this指向对象本身。

而在DOM0级和2级处理中，添加的事件处理函数

handler=function(arg1){};中，function默认的第一个argument就是event对象。（**不可以填this**）

所以不管是function(a)还是function(e)，指向的都是event对象。

**事件处理程序执行期间，event对象才会存在；事件处理程序执行完成，event对象就会被销毁**

#### ①event通用对象属性

**bubbles:** 只读 boolean 事件是否冒泡;

**cancelable：**只读 boolean 事件是否可取消;

**composed:**只读 boolean 事件是否可以穿过[**ShadowDOM**](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/Web_Components/Using_shadow_DOM)和常规DOM进行冒泡

**currentTarget:**只读 element 事件当前注册目标的引用(可能在重定向过程中被改变)

**target:**只读 element 事件的目标

```js
//target和currentTarget
//在事件处理程序内部，this始终=currentTarget,target只包含事件的实际目标
//如果一个i标签没有注册click事件，button注册了，那么点击i标签的时候，click事件冒泡到了button，这时候target和currentTarget是不同的
```

**defautPrevented:**只读 boolean 是否调用了preventDefault()方法取消了默认行为

**eventPhase:**只读 Integer 事件流正被处理到了哪个阶段(0没有事件正在被处理，1捕获阶段，2处于目标，3冒泡阶段)

**timeStamp:**只读 timestamp 事件创建时的时间戳（精度为毫秒）

**type:**只读 String 事件类型

**isTrusted:**只读 boolean 表示事件是由浏览器（例如用户点击）发起的(true)，还是由脚本（使用事件创建方法，例如 [`Event.initEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/Event/initEvent)）发出的。

**view：**只读 AbstractView  与事件关联的抽象视图，等同于发生事件的window对象 

#### **②浏览器差别实现导致的不同对象属性(举常见)**

**detail:**只读  Integer 事件细节，比如click是当前点击数，mousedown(up)是1+点击数，等等

（firefox和chrome对于滚轮事件的事件对象名不一样）

**path:**只读 Array 事件冒泡的路径对象 dom对象，顺序就是冒泡顺序（chrome实现了，firefox和safari,edge目前暂时没有）

```js
//获取event.path属性
/** 
* 需要获取事件冒泡的所有元素,Chrome有$event.path属性，FireFox和Safari没有
*/
function getEventPath($event) {
    //let path = ($event.composedPath && $event.composedPath()) || $event.path 2020/12/10不知道为什么composedPath()实装了但是返回值都是[]
    const path = $event.path,
        target = $event.target;
    if (path != null) {
        return (path.indexOf(window) < 0) ? path.concat(window) : path;
    }
    if (target === window) {
        return [window];
    }
    function getParents(node, memo) {
        memo = memo || [];
        const parentNode = node.parentNode;
        if (!parentNode) {
            return memo;
        } else {
            // console.log(memo);
            return getParents(parentNode, memo.concat(parentNode));
        }
    }
    return [target].concat(getParents(target), window);
}
```

#### ③对象方法

**preventDefault:**  cancelable=true可使用 取消事件的默认行为

**stopPropagation:** bubbles=true可使用 阻止事件的进一步捕获或者冒泡

**stopImmediatePropagation:**DOM3级事件新增 阻止事件进一步捕获或者冒泡，阻止任何事件处理程序被调用。

### IE事件对象

#### ①IE的event对象

访问IE中的event对象取决于指定事件处理程序的方法。

DOM0级添加（btn.onclick=function(){}),event对象作为window对象的一个属性存在

attachEvent()添加的时间作为参数传入事件处理程序函数中，也可以通过window对象属性访问。

通过HTML添加的和DOM中介绍的相同。

#### ②IE event对象属性

**cancelBubble:**  读写 boolean 默认false,设为true可以取消事件冒泡(stopPropagation())

**returnValue:** 读写 boolean 默认true，设为false可以取消事件默认行为(preventDefault())

**srcElement:**  只读 事件的目标(target)

**type:** String 被触发事件的类型

### 兼容跨浏览器的事件对象写法：

```js
var EventUtil = {
    addHandler: function(element, type, handler){
  	  if(element.addEventListener){
          element.addEventListener(type, handler, false);
      }else if(element.attachEvent){
          element.attachEvent("on"+type, handler);
      }else{
          element["on"+type] = handler;
      }
    },
    removeHandler: function(element, type, handler){
      if(element.removeEventListener){
          element.removeEventListener(type, handler, false);
      }else if(element.detachEvent){
          element.detachEvent("on"+type, handler);
      }else{
          element["on"+type] = null;
      }
    },
    getEvent: function(event){
        return event?event: window.event;
    },
    getTarget: function(event){
        return event.target||event.srcElement;
    },
    preventDefault: function(event){
        if(event.preventDefault){
            event.preventDefault(),
        }else{
            event.returnValue = false;
        }
    },
    stopPropagation: function(event){
        if(event.stopPropagation){
            event.stopPropagation();
        }else{
            event.cancelBubble = true;
        }
    },
    getRelatedTarget: function(event){
      	if(event.relatedTarget){
            return event.relatedTarget;
        }  else if(event.toElement){
            return event.toElement;
        }	else if(event.fromElement){
            return event.fromElement;
        }	else{
            return null;
        }
    },
};
//调用
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
	event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    EventUtil.preventDefault(event);
    EventUtil.stopPropagation(event);
};
```

### 事件类型：

DOM 3级事件在DOM 2级事件的基础上添加了更多的事件类型,全部类型如下:

```text
UI事件，当用户与页面上的元素交互时触发，如：load、scroll、resize、select、abort、unload
焦点事件，当元素获得或失去焦点时触发，如：blur、focus
鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
文本事件，当在文档中输入文本时触发，如：textInput
键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress
合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart
变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified
同时DOM3级事件也允许使用者自定义一些事件。
```

```js
var isSupported = document.implementation.hasFeature("MouseEvents","2.0");
var isSupported = document.implementation.hasFeature("MouseEvent","3.0");
```



![preview](https://segmentfault.com/img/bVbrRT3?w=999&h=636/view)



#### **keydown,keypress,keyup**事件

keydown,任意键，keyup,松开任意键,keypress,字符键

顺序 keydown->keypress;松开->keyup

**event.keycode,Firefox和Opera中分号值为59，IE和Safari为186**

IE9,Firefox,Chrome,Safari支持charCode属性，为字符的ASCII码。如果想跨平台使用则需要检测charCode属性是否可用。**（DOM3级事件移除）**

String.fromCharCode()可以转换为实际的字符。

#### textInput事件

只有可编辑区域才能触发此事件，有data属性，值是输入的字符而非字符编码(有大小写和shift)

#### 变化事件

```
var isSupported = document.implementation.hasFeature("MutationEvents","2.0")
```

DOM2级定义了如下变动事件：

- **DOMSubtreeModifined**:在DOM结构发生任何变化的时候。这个事件在其他事件触发后都会触发。
- **DOMNodeInserted**:当一个节点作为子节点被插入到另一个节点中时触发。
- **DOMNodeRemoved**:在节点从其父节点中移除时触发。
- **DOMNodeInsertedIntoDocument**：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted之后触发。
- **DOMNodeRemovedFromDocument**:在一个节点被直接从文档移除或通过子树间接从文档移除之**前**触发。这个事件在DOMNodeRemoved之后触发。
- **DOMAttrModified**：在特性被修改之后触发。
- **DOMCharacterDataModified**:在文本节点的值发生变化时触发。

举例：删除一个节点的事件触发顺序

DOMNodeRemoved(冒泡) -> DOMNodeRemovedFromDocument(被移除节点和子节点触发，不冒泡) -> DOMSubtreeModified（target是被移除节点的父节点） 

#### HTML5事件

**contextmenu：**用来添加菜单，注意要先preventDefault阻止浏览器默认的上下文菜单

**beforeunload：** 卸载页面前触发

**DOMContentLoaded：**形成完整的DOM树后就触发(load事件是页面完全加载完毕才会触发)

如果浏览器不支持，可以加载期间添加一个setTimeout(function(){},0);

**readystatechange：**支持readystatechange事件的对象都有一个readyState属性（uninitialized,loading,loaded,interactive,complete）

**pageshow与pagehide：**会话历史记录被执行时触发(前进，后退)persisted表示是否来自缓存

**hashchange：**URL参数列表（及URL中“#”后的所有字符串）发生变化时调用，必须添加给window

#### 设备事件

**orientationchange：**PC全部不支持（window.orientaition=0肖像模式，90左旋转横向模式，-90右旋转，180头朝下)

**MozOrientation：**x,y,z（0,0,1）三个属性，x表示左右倾斜（左增右减），y表示接近或远离用户倾斜（近增远减），z默认1，检测垂直加速度，移动时减小。有加速计的设备才支持事件。

**deviceorientation：**alpha(z),beta(x),gamma(y),用于定位设备的方向。absolute，表示设备是否返回一个绝对值。compassCalibrated，表示设备指南针是否校准过。有加速计的设备才支持事件

**deviceemotion：**设备是否移动。acceleration,包含xyz加速度的对象，accelerationIncludingGravity,考虑重力加速度的情况，Interval毫秒表示的时间值，rotationRate,包含alpha，beta,gamma属性的对象

#### 触摸和手势事件

**触摸事件:**touchstart.touchmove,touchend,touchcancel

除了常规属性，还包含跟踪触摸的特殊属性：

touches:表示当前跟踪触摸的Touch对象的数组，

targetTouches:特定于事件目标的Touch对象数组

changeTouches:表示自上次触摸以来发生了改变的Touch对象数组，

**触摸屏上元素时发生的事件顺序：**

touchstart -> mouseover ->mousemove(一次) -> mousedown ->mouseup -> click -> touchend

**手势事件：**gesturestart,gesturechange,gestureend

### 内存和性能：

#### ①事件委托

```js
var list = document.getElementById("myLinks");
//var item1 = document.getElementById("goSomewhere");
//var item2 = document.getElementById("doSomething");
//var item3 = document.getElementById("sayHi");
//三个item都是ul的子元素，都会冒泡，最后都会被list拿到，并且target是事件发起对象
EventUtil.addHandler(list, "click", function(event){
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    switch(target.id){
        case "doSomething":
            break;
        case "goSomewhere":
            break;
        case "sayHi":
            break;
    }
});
```

#### ②移除事件处理程序

移除元素之前，最好先移除元素的事件处理程序。

在事件处理程序中删除按钮也可以阻止事件冒泡，**目标元素在文档中是事件冒泡的前提**。

#### ③模拟事件

##### DOM中的事件模拟

DOM2级 UIEvents, MouseEvents, MutationEvents,HTMLEvents(DOM3级中都是单数)

DOM2级没有规定键盘事件

```js
var btn = document.getElementById("myBtn");
var event = document.createEvent("MouseEvents");
event.initMouseEvent("click",true,true,document.defaultView,0,0,0,0,0,false,false,false,false,0,null);
//type,bubbles,cancelable,view,detail,screenX,screenY,clientX,clientY,ctrlKey,altKey,shitKey,metaKey,button,relatedTarget
//触发事件
btn.dispatchEvent(event);
```

模拟键盘事件（DOM3)

```JS
var textbox = document.getElementById("myTextbox"),event;
if(document.implemntation.hasFeature("KeyboardEvents","3.0")){
    event = document.createEvent("KeyboardEvent");
    //初始化事件对象
    //DOM3级不提倡使用keypress事件
    event.initKeyboardEvent("keydown",true,true,document.defaultView,"a");
    //当前方法参数已经有变动了，以实际webDocs为准
    //type,bubbles,cancelable,view,key,loacation,modifiers,repeat
    //触发
    textbox.dispatchEvent(event);
}
```

自定义DOM事件

```js
var a = document.createEvent("CustomEvent");
a.initCustomEvent(type,bubbles,cancelable,detail);
```

##### IE中的事件模拟

```js
var event = document.createEventObject();
event.screenX = 100;
...
event.ctrlKey = false;
event.button = 0;

btn.fireEvent("onclick",event);
```

## 14.jQuery delegate方法

给元素的子元素添加事件处理程序

参照：输入框数字限制

```js
function limitNumber(selector) {
    selector = arguments[0]?arguments[0]:"input[type='number']";
    var reg = /[^0-9]*$/g; //edge用\d不对
    arr = [32];
    $("main").delegate(selector, 'input', function(e){
        $(this).val($(this).val().replace(reg,''));
    });
    $("main").delegate(selector, 'compositionend', function(e){
        $(this).val($(this).val().replace(reg,''));
    });
}
```

## 15.var 、let 、const 

var是函数作用域。

let和const是块级作用域。

var有变量提升，let和const没有。

```js
for(var i = 0 ; i<5; ++i){
	setTimeout(()=>console.log(i), 0); //5,5,5,5,5
}
for(let i = 0 ; i<5; ++i){
	setTimeout(()=>console.log(i), 0); //0,1,2,3,4
}
```

```js

function fn(){
   var arr = [];
   for(var i = 0;i < 5;i ++){
	 arr[i] = function(){
		 return i;
	 }
   }
   return arr;
}
var list = fn();
for(var i = 0,len = list.length;i < len ; i ++){
   console.log(list[i]());
}  // 5,5,5,5,5
```

```js
function fn(){
  var arr = [];
  for(var i = 0;i < 5;i ++){
	arr[i] = (function(i){
		return function (){
			return i;
		};
	})(i);
  }
  return arr;
}
var list = fn();
for(var i = 0,len = list.length;i < len ; i ++){
  console.log(list[i]());
}  //0,1,2,3,4
```

## 16.防抖与节流

1.防抖，事件停止一段时间后才进行事件处理

```js
function debounce(fn, delay){
    let timer = null
    return function(){
        if(timer){
            clearTimeout(timer)
        }
        timer = setTimeout(fn, delay)
    }
}
window.onscroll = debounce(fn,1000)
```

```js
function debounceAdvance(fn, delay){
    let timer
    return function() {
        clearTimeout(timer)
        timer = setTimeout(()=>{
            console.log(this, arguments)
            fn.apply(this, arguments)
        },delay)
    }
}
```

2.节流，一段时间内只执行一次事件处理函数

```js
function throttle(fn, delay){
    let valid = true
    return function(){
        if(!valid){
            return false
        }
        valid = false
        setTimeout(() => {
            fn()
            valid = true
        },delay)
    }
}
window.onscroll = throttle(fn,1000)
```

```js
function throttleAdvance(fn, delay){
    let valid = true
    return function(){
        if(!valid){
            return false
        }
        valid = false
        setTimeout(()=>{
            fn.apply(this, arguments)
            valid = true
        },delay)
    }
}
```

一般场景：

比如实时搜索框，可以节流。或者防抖

页面resize,防抖

防抖方案（Debounce）

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

节流方案（Throttle）

- 滚动加载，加载更多或滚到底部监听
- 谷歌搜索框，搜索联想功能
- 高频点击提交，表单重复提交（抢购、秒杀等）

## 17.页面隐藏元素的办法

1.visibility:hidden; 元素占用空间，元素不影响css计数器: 只触发repaint

2.display:none; 元素不占用文档空间 ，影响css计数器（点击事件是保留的，如果有label for仍可以触发）；transition属性不支持display,不识别display:none；display:none会触发reflow;

reflow必然触发repaint

3.opacity:0; 透明度为零，仍可触发点击事件

4.transform: scale(0) 缩放位无限小，原位置保留

5.div hidden="hidden"

6.height:0,然后消除边框

7.filter:blur(0) 模糊度0

8.position:absolute 负值定位到页面外面

## 18.原型，原型链

### 原型

```html
①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象
②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象
③所有引用类型的__proto__属性指向它构造函数的prototype
```

### 原型链

```html
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
```

### js中如何继承

#### 1、属性继承

```js
function Person (name, age) {
    this.name = name
    this.age = age
}

// 方法定义在构造函数的原型上
Person.prototype.getName = function () { console.log(this.name)}

function Teacher (name, age, subject) {
    Person.call(this, name, age)
    this.subject = subject
}
```

**属性的继承是通过在一个类内执行另外一个类的构造函数，通过`call`指定`this`为当前执行环境，这样就可以得到另外一个类的所有属性。**

#### 2、方法继承

```js
Teacher.prototype = Object.create(Person.prototype)
Teacher.prototype.constructor = Teacher
```

**[Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)简单说就是新建一个对象，使用现有的对象赋值给新建对象的`__proto__`**

#### 3、hasOwnProperty

**在原型链上查询属性比较耗时，对性能有影响，试图访问不存在的属性时会遍历整个原型链。**

**遍历对象属性时，每个可枚举的属性都会被枚举出来。 要检查是否具有自己定义的属性，而不是原型链上的属性，必须使用hasOwnProperty方法。**

**hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。**

#### 4、instanceof ,valueOf(), typeof 

typeof 返回的是类型的字符串值

`valueOf()`函数用于返回指定对象的原始值。该方法属于`Object`对象，由于所有的对象都"继承"了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。所有主流浏览器均支持该函数。

`instanceof` 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。

## 19.Promise

promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）

并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据

代码风格，容易理解，便于维护

多个异步等待合并便于解决

https://zhuanlan.zhihu.com/p/144058361

```js
new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) => {console.log(res)},  // 成功
  (err) => {console.log(err)} // 失败
)
```

#### 手写一个promise

```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
function Promise(executor) {
    var _this = this
    this.state = PENDING; //状态
    this.value = undefined; //成功结果
    this.reason = undefined; //失败原因

    this.onFulfilled = [];//成功的回调
    this.onRejected = []; //失败的回调
    function resolve(value) {
        if(_this.state === PENDING){
            _this.state = FULFILLED
            _this.value = value
            _this.onFulfilled.forEach(fn => fn(value))
        }
    }
    function reject(reason) {
        if(_this.state === PENDING){
            _this.state = REJECTED
            _this.reason = reason
            _this.onRejected.forEach(fn => fn(reason))
        }
    }
    try {
        executor(resolve, reject);
    } catch (e) {
        reject(e);
    }
}
Promise.prototype.then = function (onFulfilled, onRejected) {
    if(this.state === FULFILLED){
        typeof onFulfilled === 'function' && onFulfilled(this.value)
    }
    if(this.state === REJECTED){
        typeof onRejected === 'function' && onRejected(this.reason)
    }
    if(this.state === PENDING){
        typeof onFulfilled === 'function' && this.onFulfilled.push(onFulfilled)
        typeof onRejected === 'function' && this.onRejected.push(onRejected)
    }
};
```

...待完成

## 20.正则表达式

str.search()返回子串的起始位置

str.replace(Reg,'adasd')

i大小写不敏感,g全局匹配,m多行匹配,

[abc],[0-9],(x|y)

\d \s \b \w \uxxxx n+ n* n?

...待完成



## 21.HTTP1.0 1.1 2.0



## 22.如何利用缓存